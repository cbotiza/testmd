{"name":"Testmd","tagline":"TestMD Testing Library","body":"# TestMD: Fast Integration Testing (Java)\r\n\r\nAutomated testing of interactions between systems is difficult.\r\n\r\nTests normally fall in two quadrants\r\n\r\n- **\"Unit Testing\"** which perform fast, but but require mocking all external systems to be fast. This makes your tests only as valid as your assertions since the interaction with the external system is never actually tested.\r\n- **\"Integration Testing\"** which ensures the interaction with the external system is correct, but at the expense tests that are not only slow but also reliant on specific environments which are not always available\r\n\r\nTestMD gives you the speed of unit testing with the safety of integration testing by tracking how the integration is done and performing a time-consuming integration test IF AND ONLY IF there has been a change.\r\n\r\nResults of new and previous results are stored in markdown-formatted files that are designed to be human readable both in pull requests and through github source views.\r\n\r\n![Quadrants](README.quadrants.png)\r\n\r\n**TestMD: _Complete When You Need It, Fast When You Don't&trade;_**\r\n\r\n\r\n##Features\r\n\r\n**Previously Accepted Tests Stored As Markdown Format** integrates well with GitHub or any other version control views that support markdown formatting. \r\n\r\n**Previous Accepted Permutations Can Be Grouped As Tables** as needed to improve readability.\r\n\r\n**Works with JUnit, Spock, or any other testing framework**\r\n\r\n**Supports Saving \"Unverified\" results** Found a change in logic but you cannot run the automated tests? New accepted results can be committed that are marked as \"unverified\" and future runs will attempt to verify them automatically. \r\n\r\n\r\n## Getting Started: SQL Example\r\n\r\n#### Start The Test ####\r\n\r\nThe _insertData()_ method in [com.example.ExampleLogic](src/test/java/com/example/ExampleLogic.java#L9) is a simple example of a class that generates SQL.\r\n\r\nIf you are using JUnit, it is easiest to use the _TestMDRule_ class to automatically manage test naming. For more control, see [testmd.TestMd](http://nvoxland.github.io/testmd/javadoc/testmd/TestMD.html).\r\n\r\n```\r\n@Rule\r\npublic TestMDRule testmd = new TestMDRule();\r\n```\r\n\r\nYou can then begin writing your test by capturing the output of _insertData_ for your input under test\r\n\r\n```java\r\n@Test\r\npublic void insertingData_simple() throws Exception {\r\n    String tableName = \"test_table\";\r\n    String[] columns = new String[] {\"age\", \"name\"};\r\n    Object[] values = new Object[] {42, \"Fred\"}; \r\n    String sql = new ExampleLogic().generateInsertSql(tableName, columns, values);\r\n    \r\n    //GOING TO ADD MORE HERE\r\n}\r\n```\r\n\r\nAll the test is doing so far is calling the method that generates an insert statement and saving the SQL for testing. At this point, there should be no calls out to external systems or anything else that would slow the test execution because this portion of the test is ALWAYS executed.\r\n\r\nOnce you have the SQL, we will use TestMD to ensure that it is correct by actually executing it if and only if it is changed.\r\n\r\n#### Define Parameteres ####\r\n\r\nFirst, we define a new permutation and describe it with parameters. The parameters uniquely identify the permutation:\r\n\r\n```java\r\n@Test\r\npublic void insertingData_simple() throws Exception {\r\n    String tableName = \"test_table\";\r\n    String[] columns = new String[] {\"age\", \"name\"};\r\n    Object[] values = new Object[] {42, \"Fred\"};\r\n    String sql = new ExampleLogic().generateInsertSql(tableName, columns, values);\r\n\r\n    testmd.permutation()\r\n            .addParameter(\"tableName\", tableName)\r\n            .addParameter(\"columns\", columns)\r\n            .addParameter(\"values\", values);\r\n    //GOING TO ADD MORE HERE\r\n}\r\n```   \r\n    \r\nNotice that the _TestMD_ object is designed to simply chain method calls together for an easier to read test. You should add a parameter for each key/value that helps uniquely identify this particular test case.\r\n\r\n#### Define Results ####\r\n\r\nOnce we have a parameters defined, we add our \"results\" to the permutation:\r\n\r\n```java\r\n@Test\r\npublic void insertingData_simple() throws Exception {\r\n    String tableName = \"test_table\";\r\n    String[] columns = new String[] {\"age\", \"name\"};\r\n    Object[] values = new Object[] {42, \"Fred\"};\r\n    String sql = new ExampleLogic().generateInsertSql(tableName, columns, values);\r\n\r\n    testmd.permutation()\r\n            .addParameter(\"tableName\", tableName)\r\n            .addParameter(\"columns\", columns)\r\n            .addParameter(\"values\", values)\r\n            .addResult(\"sql\", sql);\r\n    //GOING TO ADD MORE HERE\r\n}  \r\n```\r\n\r\nYou can include as many result key/value pairs as you need and if any of them are different, the permutation will be re-verified. In our case, we just have one result to worry about.\r\n\r\n#### Define Setup Logic ####\r\n\r\nNow that we have the permutation defined, we can add logic for how to test it (if needed). First, there is usually some setup that needs to be done. This may include connecting to the database, truncating existing data, or anything else you need:\r\n\r\n\r\n```java\r\nprivate Connection connection;\r\n\r\n@Test\r\npublic void insertingData_simple() throws Exception {\r\n    String tableName = \"test_table\";\r\n    String[] columns = new String[] {\"age\", \"name\"};\r\n    Object[] values = new Object[] {42, \"Fred\"};\r\n    String sql = new ExampleLogic().generateInsertSql(tableName, columns, values);\r\n\r\n    testmd.permutation()\r\n            .addParameter(\"tableName\", tableName)\r\n            .addParameter(\"columns\", columns)\r\n            .addParameter(\"values\", values)\r\n            .addResult(\"sql\", sql)\r\n            .setup(new Setup() {\r\n                @Override\r\n                public void run() throws SetupResult {\r\n                    openConnection();\r\n                    if (connection == null) {\r\n                        throw new SetupResult.CannotVerify(\"Connection not available\");\r\n                    }\r\n                    resetDatabase();\r\n                    throw SetupResult.OK;\r\n                }\r\n            });\r\n    //GOING TO ADD MORE HERE\r\n}\r\n```\r\n\r\nIf you cannot set up the environment for testing, throw SetupResult.CannotVerify. If everything is correctly set up, throw SetupResult.OK.\r\n\r\n#### Define Cleanup Logic ####\r\n\r\nIf anything needs to be cleaned up after the test runs, add a \"cleanup\" call:\r\n\r\n```java\r\n@Test\r\npublic void insertingData_simple() throws Exception {\r\n    String tableName = \"test_table\";\r\n    String[] columns = new String[]{\"age\", \"name\"};\r\n    Object[] values = new Object[]{42, \"Fred\"};\r\n    String sql = new ExampleLogic().generateInsertSql(tableName, columns, values);\r\n\r\n    testmd.permutation()\r\n            .addParameter(\"tableName\", tableName)\r\n            .addParameter(\"columns\", columns)\r\n            .addParameter(\"values\", values)\r\n            .addResult(\"sql\", sql)\r\n            .setup(new Setup() {\r\n                @Override\r\n                public void run() throws SetupResult {\r\n                    openConnection();\r\n                    if (connection == null) {\r\n                        throw new SetupResult.CannotVerify(\"Connection not available\");\r\n                    }\r\n                    resetDatabase();\r\n                    throw SetupResult.OK;\r\n                }\r\n            }).cleanup(new Cleanup() {\r\n                @Override\r\n                public void run() throws CleanupException {\r\n                    closeConnection();\r\n                }\r\n    });\r\n    //GOING TO ADD MORE HERE\r\n}\r\n``` \r\n\r\n#### Define Assertion Logic ####\r\n\r\nWe are now ready for our actual assertions and our final code:\r\n\r\n```java\r\npublic class ExampleJUnitTest {\r\n\r\n\t@Rule\r\n\tpublic TestMDRule testmd = new TestMDRule();\r\n\tprivate Connection connection;\r\n\t\r\n\t@Test\r\n\tpublic void insertingData_simple() throws Exception {\r\n\t    final String tableName = \"test_table\";\r\n\t    final String[] columns = new String[]{\"age\", \"name\"};\r\n\t    final Object[] values = new Object[]{42, \"Fred\"};\r\n\t    final String sql = new ExampleLogic().generateInsertSql(tableName, columns, values);\r\n\t\r\n\t    testmd.permutation()\r\n\t            .addParameter(\"tableName\", tableName)\r\n\t            .addParameter(\"columns\", columns)\r\n\t            .addParameter(\"values\", values)\r\n\t            .addResult(\"sql\", sql)\r\n\t            .setup(new Setup() {\r\n\t                @Override\r\n\t                public void run() throws SetupResult {\r\n\t                    openConnection();\r\n\t                    if (connection == null) {\r\n\t                        throw new SetupResult.CannotVerify(\"Connection not available\");\r\n\t                    }\r\n\t                    resetDatabase();\r\n\t                    throw SetupResult.OK;\r\n\t                }\r\n\t            }).cleanup(new Cleanup() {\r\n\t                @Override\r\n\t                public void run() throws CleanupException {\r\n\t                    closeConnection();\r\n\t                }\r\n\t    }).run(new Verification() {\r\n\t        @Override\r\n\t        public void run() throws CannotVerifyException, AssertionError {\r\n\t            executeSql(sql);\r\n\t            assertDataInserted(tableName, columns, values);\r\n\t        }\r\n\t    });\r\n\t}\r\n}\r\n```\r\n\r\nWithin the _Verification_ call, you actually execute the genearted SQL, then run any assertion logic you need to ensure that it runs successfully.\r\n\r\n#### Run The Test ####\r\n\r\nNow run your test method like you would run any JUnit test. The first time it executes, it will take longer to execute--especially if you have real database connection logic in _openConnection()_ and _executeSql()_.\r\n\r\nRunning it a second time, however, will take virtually no time at all. The secret is the [src/test/resources/com/example/ExampleJUnitTest.insertingData_simple.accepted.md](src/test/resources/com/example/ExampleJUnitTest.insertingData_simple.accepted.md) file that gets created in on your file system. That file stores the fact that the *ExampleJUnitTest.insertingData_simple* test was ran successfully with \"table=test_table, columns=[age, name] and values=[42, Fred]\". It also lists the SQL that was executed as the result.\r\n\r\nIf you manually edit the sql stored in the accepted.md file and re-run your test, you will see that the SQL is re-executed and verified and the file is re-written as verified again. \r\n\r\nIf you delete the existing accepted.md file and change the _Setup_ logic to throw a _SetupResult.CannotVerify_ exception, when you rerun the test the file will be re-written and the test will be marked as \"UNVERIFIED: Connection not available\". Make the test no longer throw _CannotVerify_ and re-run the test and it will be saved as VERIFIED.\r\n\r\n#### Commit The accepted.md File ####\r\n\r\nWhenever you have a new test using TestMD, commit the corresponding accepted.md files. Now any other developers running your tests will only need to re-verify the SQL if they make a change that alters the generated SQL. \r\n\r\nAs you are working on your application, watch for changes to accepted.md files. Are there suddenly results that changed unexpectedly? Are those changes verified? The markdown format is designed to be easily readable in any diff program so watch them as part of every commit.\r\n\r\nAre you wondering what has been tested? The markdown format is also designed to be readable through GitHub or any other markdown compatible web view. Simply go to the directory containing your tests such as [src/test/resources/com/example](src/test/resources/com/example/) and read through what has been tested.\r\n\r\n#### Multiple Permutation Per Test ####\r\n\r\nUsually, one test of a method is not enough to ensure it is working correctly--you need to test it with multiple different value permutations. The TestMD accepted.md format is designed to group multiple different test runs into a single test file for easier readability. \r\n\r\nFor a given testClass/testName combination, you can define as many permutations as you want. Each one is uniquely identified by its parameters and re-ran if the results change.\r\n\r\nIn this test:\r\n\r\n```java\r\n@Test\r\npublic void insertingData() throws Exception {\r\n    ExampleLogic logic = new ExampleLogic();\r\n\r\n    Object[][] permutations = new Object[][]{\r\n            new Object[]{\"person\", new String[]{\"name\"}, new Object[]{\"Bob\"}},\r\n            new Object[]{\"person\", new String[]{\"age\"}, new Object[]{42}},\r\n            new Object[]{\"person\", new String[]{\"name\", \"age\"}, new Object[]{\"Joe\", 55}},\r\n            new Object[]{\"address\", new String[]{\"address1\", \"address2\", \"city\"}, new Object[]{\"121 Main\", null, \"New Town\"}}\r\n    };\r\n\r\n    for (Object[] permutation : permutations) {\r\n        final String tableName = (String) permutation[0];\r\n        final String[] columns = (String[]) permutation[1];\r\n        final Object[] values = (Object[]) permutation[2];\r\n\r\n        final String sql = logic.generateInsertSql(tableName, columns, values);\r\n        testmd.permutation()\r\n                .addParameter(\"table\", tableName)\r\n                .addParameter(\"columns\", columns)\r\n                .addParameter(\"values\", values)\r\n                .addResult(\"sql\", sql)\r\n                .run(new Verification() {\r\n                    @Override\r\n                    public void run() {\r\n                        executeSql(sql);\r\n                        assertDataInserted(tableName, columns, values);\r\n                    }\r\n                });\r\n    }\r\n}\r\n```  \r\n\r\nwe define multiple permutations and then loop through them with a resulting file that looks like [src/test/resources/com/example/ExampleJUnitTest.insertingData.accepted.md](src/test/resources/com/example/ExampleJUnitTest.insertingData.accepted.md)\r\n\r\n#### Formatting Permutations As A Table ####\r\n\r\nDepending on what is being tested, it sometimes helps readability to group permutations in a table. Adding a call to _.asTable(parameterNames)_ in the permutation definition allows you define the names of the parameters that should be used in the table.\r\n\r\nFor example:\r\n\r\n```java\r\n@Test\r\npublic void insertingDataFormattedAsTable() throws Exception {\r\n    ExampleLogic logic = new ExampleLogic();\r\n\r\n    Object[][] permutations = new Object[][]{\r\n            new Object[]{\"person\", new String[]{\"name\"}, new Object[]{\"Bob\"}},\r\n            new Object[]{\"person\", new String[]{\"age\"}, new Object[]{42}},\r\n            new Object[]{\"person\", new String[]{\"name\", \"age\"}, new Object[]{\"Joe\", 55}},\r\n            new Object[]{\"address\", new String[]{\"address1\", \"address2\", \"city\"}, new Object[]{\"121 Main\", null, \"New Town\"}}\r\n    };\r\n\r\n    for (Object[] permutation : permutations) {\r\n        final String tableName = (String) permutation[0];\r\n        final String[] columns = (String[]) permutation[1];\r\n        final Object[] values = (Object[]) permutation[2];\r\n\r\n        final String sql = logic.generateInsertSql(tableName, columns, values);\r\n        testmd.permutation()\r\n                .addParameter(\"table\", tableName)\r\n                .addParameter(\"columns\", columns)\r\n                .addParameter(\"values\", values)\r\n                .asTable(\"columns\", \"values\")\r\n                .addResult(\"sql\", sql)\r\n                .run(new Verification() {\r\n                    @Override\r\n                    public void run() {\r\n                        executeSql(sql);\r\n                        assertDataInserted(tableName, columns, values);\r\n                    }\r\n                });\r\n    }\r\n\r\n}\r\n```  \r\n\r\nwill save the results as [src/test/resources/com/example/ExampleJUnitTest.insertingDataFormattedAsTable.accepted.md](src/test/resources/com/example/ExampleJUnitTest.insertingDataFormattedAsTable.accepted.md).\r\n\r\nFunctionality-wise there is no difference between table-formatted and regular-formatted accepted.md files. Use whatever is most readable for each test.\r\n\r\n## Other Uses: Not Just SQL\r\n\r\nTestMD works well any time you are able to describe the interaction between two systems in a simple yet deterministic way. \r\n\r\nREST-style webservices work well with TestMD:\r\n\r\n```java\r\n@Test\r\npublic void queryAPI() throws Exception {\r\n    ExampleLogic logic = new ExampleLogic();\r\n\r\n    Object[][] permutations = new Object[][]{\r\n            new Object[]{\"cars\", 4},\r\n            new Object[]{\"testing examples\", 3},\r\n            new Object[]{\"junit alternatives\", 3},\r\n            new Object[]{\"junit alternatives\", 3}\r\n    };\r\n\r\n    for (Object[] permutation : permutations) {\r\n        final String keywords = (String) permutation[0];\r\n        int version = (Integer) permutation[1];\r\n        final String query = logic.generateQueryRequest(version, keywords);\r\n        testmd.permutation().addParameter(\"keywords\", keywords)\r\n                .addParameter(\"version\", version)\r\n                .asTable(\"keywords\", \"version\")\r\n                .addResult(\"query\", query)\r\n                .run(new Verification() {\r\n                    @Override\r\n                    public void run() {\r\n                        assertQueryResults(query, keywords);\r\n                    }\r\n                });\r\n\r\n    }\r\n}\r\n```\r\n\r\nAs do:\r\n\r\n- NoSQL database interactions \r\n- SOAP and RPC calls\r\n- And More\r\n     \r\n## Spock Example ##\r\n\r\nTestMD is designed to work well with the Spock testing framework. Because of the improved permutation support in Spock, the tests tend to be even cleaner than JUnit.\r\n\r\n```groovy\r\n@Unroll\r\ndef \"inserting data\"() {\r\n    expect:\r\n    ExampleLogic logic = new ExampleLogic();\r\n\r\n    //Using TestMD.test directly to avoid a separate accepted.md file for each permutation\r\n    def sql = logic.generateInsertSql(tableName, columns, values)\r\n    TestMD.test(this.class, \"inserting data\").permutation([table: tableName, columns: columns, values: values])\r\n            .addResult(\"sql\", sql)\r\n            .run({\r\n        executeSql(sql)\r\n        assertDataInserted(tableName, columns, values)\r\n    } as Verification)\r\n\r\n    where:\r\n    tableName | columns                                      | values\r\n    \"person\"  | [\"name\"] as String[]                         | [\"Bob\"] as Object[]\r\n    \"person\"  | [\"age\"] as String[]                          | [42] as Object[]\r\n    \"person\"  | [\"name\", \"age\"] as String[]                  | [\"Joe\", 55] as Object[]\r\n    \"address\" | [\"address1\", \"address2\", \"city\"] as String[] | [\"121 Main\", null, \"New Town\"] as Object[]\r\n}\r\n```\r\n\r\n## Final Details ##\r\n\r\n- Congratulations on reading all the way to the bottom of this README.\r\n- If you have any bugs or feature enhancements, use the Github Project Issues\r\n- Pull requests area always appreciated\r\n- Feel free to contact me at nathan@liquibase.org or [@nvoxland](https://twitter.com/nvoxland) with any additional questions or comments\r\n- Each permutation in the accepted.md files contain a 6 digit alphanumeric \"key\" that is used to easily identify the permutation, even if the order is shifted.\r\n- The accepted.md file stores results in an automatically-sorted manner to make diffs more consistent.\r\n- You can control the formatting of parameters and results in the accepted.md file with a [ValueFormat](http://nvoxland.github.io/testmd/javadoc/testmd/ValueFormat.html) object if needed. Just use the overloaded _addParameter()_ and _addResult()_ methods.\r\n- You can call _addNote(key, note)_ to your permutation definition to save informational notes in the accepted.md file. These notes do not affect the identification of permutations or the decision to re-verify them.\r\n- Javadoc is available at [http://nvoxland.github.io/testmd/javadoc](http://nvoxland.github.io/testmd/javadoc/index.html)\r\n- Happy Testing!\r\n\r\n  ","google":"UA-57739912-1","note":"Don't delete this file! It's used internally to help with page regeneration."}